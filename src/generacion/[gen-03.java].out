.CODE
PUSH simple_heap_init
CALL
PUSH lblMetmain@Init
CALL
HALT
simple_heap_init: RET 0	; Retorna inmediatamente
simple_malloc: LOADFP	; Inicialización unidad
LOADSP
STOREFP ; Finaliza inicialización del RA
LOADHL	; hl
DUP	; hl
PUSH 1	; 1
ADD	; hl+1
STORE 4 ; Guarda el resultado (un puntero a la primer celda de la región de memoria)
LOAD 3	; Carga la cantidad de celdas a alojar (parámetro que debe ser positivo)
ADD
STOREHL ; Mueve el heap limit (hl). Expande el heap
STOREFP
RET 1	; Retorna eliminando el parámetro



.DATA
lblVTA: DW lblMetm1@A,lblMetm2@A

.CODE

lblConstructor@A: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
FMEM 0
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

lblMetm1@A: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
LOAD 4 ; Apilo el valor en memoria del offset de p1
PUSH lblMetdebugPrint@Object  ; Apila el método 
CALL  ; Llama al método en el tope de la pila
FMEM 0
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 2

lblMetm2@A: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
FMEM 0
PUSH 33  ; Apila el entero 33
STORE 4
STOREFP  ; Actualizar el fp para que apunte al RA del llamador
RET 1
FMEM 0
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

.DATA
lblVTInit: NOP

.CODE

lblConstructor@Init: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
FMEM 0
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

lblMetmain@Init: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
RMEM 1  ; Reservo un lugar en memoria para almacenar el valor de la var local x
RMEM 1  ; Reservamos memoria para el resultado del malloc (la referencia al nuevo CIR de A)
PUSH 1  ;  Apilo la cantidad de var de instancia del CIR de A +1 por VT
PUSH simple_malloc  ; La dirección de la rutina para alojar memoria en el heap
CALL  ; Llamo a malloc
DUP  ; Para no perder la referencia al nuevo CIR
PUSH lblVTA  ; Apilamos la dirección del comienzo de la VT de la clase A
STOREREF 0  ; Guardamos la Referencia a la VT en el CIR que creamos
DUP
PUSH lblConstructor@A
CALL  ; Llamo al constructor lblConstructor@A
STORE 0  ; Almaceno el valor de la expresión de la var local x
LOAD 0 ; Apilo el valor en memoria del offset de x
RMEM 1  ; Reservamos una locación de memoria para guardar el resultado de m2
SWAP
DUP
LOADREF 0  ; Apilo el offset de la VT en el CIR (siempre 0)
LOADREF 1  ; Apilo el offset del método m2 en la VT
CALL  ; Llama al método en el tope de la pila
POP  ; La llamada devolvió algo distinto de void ->  se descarta
LOAD 0 ; Apilo el valor en memoria del offset de x
RMEM 1  ; Reservamos una locación de memoria para guardar el resultado de m2
SWAP
DUP
LOADREF 0  ; Apilo el offset de la VT en el CIR (siempre 0)
LOADREF 1  ; Apilo el offset del método m2 en la VT
CALL  ; Llama al método en el tope de la pila
PUSH lblMetdebugPrint@Object  ; Apila el método 
CALL  ; Llama al método en el tope de la pila
FMEM 1
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 0

.DATA
lblVTObject: NOP

.CODE

lblConstructor@Object: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
FMEM 0
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

lblMetdebugPrint@Object: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
LOAD 3  ; Apila el parámetro
IPRINT  ; Imprime el entero en el tope de la pila
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

.DATA
lblVTString: NOP

.CODE

lblConstructor@String: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
FMEM 0
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

.DATA
lblVTSystem: NOP

.CODE

lblConstructor@System: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
FMEM 0
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

lblMetprintC@System: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
LOAD 3  ; Apila el parámetro
CPRINT  ; Imprime el char en el tope de la pila
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

lblMetprintS@System: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
LOAD 3  ; Apila el parámetro
SPRINT  ; Imprime el string en el tope de la pila
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

lblMetprintln@System: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
PRNLN  ; Imprime el caracter de nueva línea
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 0

lblMetprintCln@System: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
LOAD 3  ; Apila el parámetro
CPRINT  ; Imprime el char en el tope de la pila
PRNLN  ; Imprime el caracter de nueva línea
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

lblMetprintSln@System: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
LOAD 3  ; Apila el parámetro
SPRINT  ; Imprime el booleano en el tope de la pila
PRNLN  ; Imprime el caracter de nueva línea
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

lblMetread@System: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
READ  ; Lee un valor entero
PUSH 48  ; Por ASCII
SUB
STORE 3  ; Devuelve el valor entero leído, poniendo el tope de la pila en la locación reservada
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 0

lblMetprintB@System: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
LOAD 3  ; Apila el parámetro
BPRINT  ; Imprime el booleano en el tope de la pila
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

lblMetprintIln@System: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
LOAD 3  ; Apila el parámetro
IPRINT  ; Imprime el entero en el tope de la pila
PRNLN  ; Imprime el caracter de nueva línea
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

lblMetprintI@System: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
LOAD 3  ; Apila el parámetro
IPRINT  ; Imprime el entero en el tope de la pila
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

lblMetprintBln@System: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
LOAD 3  ; Apila el parámetro
BPRINT  ; Imprime el booleano en el tope de la pila
PRNLN  ; Imprime el caracter de nueva línea
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1
